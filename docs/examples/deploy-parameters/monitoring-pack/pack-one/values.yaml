targetNamespace: monitoring

nameOverride: ""
fullnameOverride: ""

commonLabels: {}
commonAnnotations: {}

# Standard labels that will be applied to ServiceMonitor resources
# Default value: platform.monitoring.type: exporter
# Can be overridden by setting this value
standardLabels: {}

rbac:
  # Enable RBAC resources creation
  install: true
  # Additional labels for RBAC resources
  labels: {}
  # Additional annotations for RBAC resources
  annotations: {}
  vmAgent:
    # Override default service account name (empty = auto-generated)
    serviceAccountName: ""
    # Override default cluster role name (empty = auto-generated)
    clusterRoleName: ""
    # Override default cluster role binding name (empty = auto-generated)
    clusterRoleBindingName: ""
    # Override default role name (empty = auto-generated)
    roleName: ""
    # Override default role binding name (empty = auto-generated)
    roleBindingName: ""
    # Override default cluster rules (empty = use defaults from template)
    clusterRules: []
    # Override default role rules (empty = use defaults from template)
    roleRules: []
  vmAlert:
    # Override default service account name (empty = auto-generated)
    serviceAccountName: ""
    # Override default cluster role name (empty = auto-generated)
    clusterRoleName: ""
    # Override default cluster role binding name (empty = auto-generated)
    clusterRoleBindingName: ""
    # Override default role name (empty = auto-generated)
    roleName: ""
    # Override default role binding name (empty = auto-generated)
    roleBindingName: ""
    # Override default cluster rules (empty = use defaults from template)
    clusterRules: []
    # Override default role rules (empty = use defaults from template)
    roleRules: []

vmAgent:
  install: true
  name: vmagent
  labels: {}
  annotations: {}
  spec:
    arbitraryFSAccessThroughSMs: {}
    externalLabels:
      cluster: example-cluster
    extraArgs:
      promscrape.streamParse: "true"
    resources:
      limits:
        cpu: "1"
        memory: 2000Mi
      requests:
        cpu: 100m
        memory: 500Mi
    scrapeInterval: 30s
    remoteWrite:
      - url: https://remote-write.example.com/api/v1/write

vmAlert:
  install: true
  name: vmalert
  labels: {}
  annotations: {}
  spec:
    datasource:
      url: https://remote-write.example.com
    evaluationInterval: 30s
    notifier:
      url: https://alertmanager.example.com
    remoteWrite:
      url: https://alertmanager.example.com/api/v1/alerts
    ruleSelector: {}
    ruleNamespaceSelector: {}

serviceMonitors:
  namespaceSelector: {}
  exporters:
    kubeStateMetrics:
      install: true
      selector:
        matchLabels:
          platform.monitoring.app: kube-state-metrics
      namespace: monitoring
      endpoints:
        - port: http-metrics
          interval: 30s
    nodeExporter:
      install: true
      selector:
        matchLabels:
          platform.monitoring.app: node-exporter
      namespace: monitoring
      endpoints:
        - port: metrics
          interval: 30s
    cloudEventsExporter:
      install: true
      selector:
        # Note: If targetNamespace is not "monitoring", update the value to match "{targetNamespace}-cloud-events-exporter"
        matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
              - monitoring-cloud-events-exporter
      namespace: monitoring
      endpoints:
        - port: metrics
          interval: 30s
    versionExporter:
      install: true
      jobLabel: version-exporter
      selector:
        matchLabels:
          app.kubernetes.io/name: version-exporter
      namespace: monitoring
      # Note: version-exporter ServiceMonitor in original chart doesn't have namespaceSelector
      # If Service is in different namespace, set namespaceSelector to empty {} to search in all namespaces
      namespaceSelector: {}
      endpoints:
        - port: http
          path: /metrics
          scheme: http
          interval: 5m
          scrapeTimeout: 30s
